# 数组的总结

## 1. 数组的定义

> 数组是一组相同类型元素的集合

## 2. 一维数组的创建和初始化

> ### (1). 数组的创建
>
> 1.  int arr[10]
>
>     float arr1[5];
>
>    double arr2[3];
>
> 2. 数组创建时, [ ]中只能存放整型常量,不能存放变量
>
>    int count = 10;
>
>    int arr[count];
>
>    即使count的值为10, 但count本身还是一个变量, 所以不能放于[ ]中

> ### (2). 数组的初始化
>
> 1. 定义的时候同时初始化
>
>    int arr[10] = {1, 2, 3, 4, 5};  // 不完全初始化
>
>    int arr1[5] = {0};
>
> 2. 定义的时候不指定数组的大小, 由初始化的数组元素来确定大小
>
> ​       int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // 此时数组的大小为 10
>
> 3. 数组在初始化时也可以初始化成字符
>
>    char arr[3] = {'a', 'b', 'c'};
>
>    char arr1[3] = {'a', 98, 'c'};  // b在ASCII表中所对应的数字为98, 因此可以用98代替b
>
> 4. 数组也可以初始化成一组字符串
>
>    int arr[] = "abcdef";

## 3. 一维数组的使用

> ###  (1). 访问数组中的各个元素
>
> ```c
> int main() {
> 	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
> 	int sz = sizeof(arr) / sizeof(arr[0]); // 数组的长度
> 	int i = 0;
> 	for (i = 0; i < sz; i++) {
> 		printf("%d ", arr[i]); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
> 	}
> 	return 0;
> }
> ```
>
> 注意: 1. 数组下标是从0开始的, 直到数组长度-1为止. 
>
> ​              因此以后凡是有数组的问题, 一定要考虑到数组下标是从0开始的, 防止数组越界的行为发生
>
> ​          2. 数组的大小是可以通过计算得到的
>
> ### (2). 一维数组在内存中的存储
>
> 数组在内存中是连续存储的
>
> ```c
> int main() {
> 	int arr[] = { 1, 2, 3, 4, 5 };
> 	int sz = sizeof(arr) / sizeof(arr[0]);
> 	int i = 0;
> 	for (i = 0; i < sz; i++) {
> 		printf("%p\n", &arr[i]);
> 	}
> 	return 0;
> }
> ```
>
> 得到的结果为
>
> ![](C:\Users\Huyue\AppData\Roaming\Typora\typora-user-images\image-20200401155252386.png)

## 4. 二维数组的创建和初始化

> ### (1). 二位数组的创建
>
> ```c
> int arr[3][4]; // 创建了一个3行4列的二维数组
> char arr1[3][5];
> ```
>
> ### (2). 二维数组的初始化
>
> ```c
> int arr[3][4] = {1, 2, 3, 4};
> int arr[3][4] = {{1,2}, {3, 4}};
> int arr[][4] = {{0,1}, {2, 3}}; 
> ```
>
> 二维数组在初始化的时候, 可以省略行, 但是不能省略列
>
> 二维数组其实在创建的过程中, 是连续的, 一行紧挨着一行. 因此, 若省略了行数, 可以根据初始化的内容而来判断有多少行. 但是一旦省略列数的话, 就不会知道一行有多少元素, 第二行从哪里开始也是未知的
>
> ![image-20200401160607431](C:\Users\Huyue\AppData\Roaming\Typora\typora-user-images\image-20200401160607431.png) 

## 5. 二维数组的使用

> ### (1) 访问数组中的各元素
>
> ```c
> int main() {
> 	int arr[3][4] = { 1, 2, 3, 4, 5 };
> 	int i = 0;
> 	for (i = 0; i < 3; i++) {
> 		int j = 0;
> 		for (j = 0; j < 4; j++) {
> 			printf("%d ", arr[i][j]);
> 		}
> 		printf("\n");
> 	}
> 	return 0;
> }
> ```
>
> 得到的结果为
>
> ![image-20200401161252119](C:\Users\Huyue\AppData\Roaming\Typora\typora-user-images\image-20200401161252119.png)
>
> 由此可见, 二维数组中, 无论是行的元素下标还是列的元素下标, 都是从0开始的
>
> ### (2). 二维数组在内存中的存储
>
> ```c
> int main() {
> 	int arr[2][3] = { 1, 2, 3, 4, 5 };
> 	int i = 0;
> 	for (i = 0; i < 2; i++) {
> 		int j = 0;
> 		for (j = 0; j < 3; j++) {
> 			printf("&arr[%d][%d] = %p\n", i, j, &arr[i][j]);
> 		}
> 	}
> 	return 0;
> }
> ```
>
> 结果为:
>
> ![image-20200401161721462](C:\Users\Huyue\AppData\Roaming\Typora\typora-user-images\image-20200401161721462.png)
>
> 由此可见, 二维数组在内存中也是连续存储的

## 6. 数组作为函数参数

> 数组作为函数参数时, 一般情况下, 数组名就是数组首元素的地址(有两个例外)
>
> 1. sizeof(数组名), 计算数组的整个大小, 这时数组名表示整个数组;
> 2. &数组名, 取出的是数组的地址, 这时数组名表示整个数组
>
> 由于传参的时候是首元素地址, 因此就不能在函数内部计算数组的大小(  sizeof(arr) / sizeof(arr[0])  )
>
> 要在函数外部计算出大小之后再通过参数的形式传递给函数内部进行使用.

## 总结

> 1. 一定要记住数组的下标是从0开始的, 在进行数组的运算时, 不能发生下标越界的行为
> 2. 访问数组的元素时, 要通过元素下标进行访问
> 3. 无论是一维数组还是二维数组, 它们在内存中都是连续存储的
> 4. 数组在传参的时候, 传入函数中的是首元素的地址(除了两个例外)
>
> 